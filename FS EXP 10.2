// app.js - Single-file Blog Platform (frontend + backend)
// Run: npm init -y
//      npm install express mongoose bcryptjs jsonwebtoken
// Optional: export MONGODB_URI="mongodb://user:pass@host:27017/blogdb"
// Optional: export JWT_SECRET="your_secret"
// Then: node app.js

const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const path = require('path');

const app = express();
app.use(express.json());

// Config
const JWT_SECRET = process.env.JWT_SECRET || 'CHANGE_THIS_SECRET';
const mongoUri = process.env.MONGODB_URI || '';
let useMongo = false;

// In-memory fallback stores
const mem = {
  users: [],       // { id, username, name, passwordHash, bio }
  posts: [],       // { id, authorId, title, body, createdAt, updatedAt }
  comments: [],    // { id, postId, authorId, text, createdAt }
  nextId: 1
};

// SSE listeners for comments per postId
const sseListeners = {}; // postId => Set of res

// ----- Mongoose models when MongoDB available -----
let UserModel, PostModel, CommentModel;

async function initDB() {
  if (!mongoUri) {
    console.log('MONGODB_URI not set — using in-memory store (demo only).');
    return;
  }
  try {
    await mongoose.connect(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true });
    const userSchema = new mongoose.Schema({
      username: { type: String, required: true, unique: true },
      name: String,
      passwordHash: String,
      bio: String
    }, { timestamps: true });

    const postSchema = new mongoose.Schema({
      authorId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      title: String,
      body: String
    }, { timestamps: true });

    const commentSchema = new mongoose.Schema({
      postId: { type: mongoose.Schema.Types.ObjectId, ref: 'Post' },
      authorId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      text: String
    }, { timestamps: true });

    UserModel = mongoose.model('User', userSchema);
    PostModel = mongoose.model('Post', postSchema);
    CommentModel = mongoose.model('Comment', commentSchema);

    useMongo = true;
    console.log('Connected to MongoDB.');
  } catch (err) {
    console.error('MongoDB connection failed — falling back to in-memory store.', err.message);
  }
}
initDB();

// ----- Utilities -----
function genId() { return String(mem.nextId++); }
function now() { return new Date().toISOString(); }

function signToken(payload) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
}

function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (e) {
    return null;
  }
}

// Auth middleware (checks Authorization: Bearer <token>)
async function authMiddleware(req, res, next) {
  const header = req.headers.authorization;
  if (!header || !header.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing token' });
  const token = header.slice(7);
  const data = verifyToken(token);
  if (!data) return res.status(401).json({ error: 'Invalid token' });

  if (useMongo) {
    const user = await UserModel.findById(data.id).exec();
    if (!user) return res.status(401).json({ error: 'User not found' });
    req.user = { id: user._id.toString(), username: user.username, name: user.name, bio: user.bio };
  } else {
    const u = mem.users.find(x => x.id === data.id);
    if (!u) return res.status(401).json({ error: 'User not found' });
    req.user = { id: u.id, username: u.username, name: u.name, bio: u.bio };
  }
  next();
}

// ----- Helper: broadcast comment via SSE -----
function broadcastComment(postId, commentObj) {
  const list = sseListeners[postId];
  if (!list) return;
  const payload = JSON.stringify(commentObj);
  for (const res of Array.from(list)) {
    try {
      res.write(`event: comment\n`);
      res.write(`data: ${payload}\n\n`);
    } catch (e) {
      // ignore write errors
    }
  }
}

// ----- API routes -----

// --- Auth: signup & login ---
app.post('/api/auth/signup', async (req, res) => {
  try {
    const { username, password, name, bio } = req.body;
    if (!username || !password) return res.status(400).json({ error: 'username and password required' });

    if (useMongo) {
      const exists = await UserModel.findOne({ username }).exec();
      if (exists) return res.status(400).json({ error: 'username taken' });
      const passwordHash = await bcrypt.hash(password, 10);
      const u = await UserModel.create({ username, name: name || '', passwordHash, bio: bio || '' });
      const token = signToken({ id: u._id.toString() });
      return res.status(201).json({ token, user: { id: u._id, username: u.username, name: u.name, bio: u.bio } });
    } else {
      if (mem.users.some(u => u.username === username)) return res.status(400).json({ error: 'username taken' });
      const passwordHash = await bcrypt.hash(password, 10);
      const id = genId();
      const user = { id, username, name: name || '', passwordHash, bio: bio || '' };
      mem.users.push(user);
      const token = signToken({ id });
      return res.status(201).json({ token, user: { id, username, name: user.name, bio: user.bio } });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'signup failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    if (!username || !password) return res.status(400).json({ error: 'username and password required' });

    if (useMongo) {
      const u = await UserModel.findOne({ username }).exec();
      if (!u) return res.status(400).json({ error: 'invalid credentials' });
      const ok = await bcrypt.compare(password, u.passwordHash);
      if (!ok) return res.status(400).json({ error: 'invalid credentials' });
      const token = signToken({ id: u._id.toString() });
      return res.json({ token, user: { id: u._id, username: u.username, name: u.name, bio: u.bio } });
    } else {
      const u = mem.users.find(x => x.username === username);
      if (!u) return res.status(400).json({ error: 'invalid credentials' });
      const ok = await bcrypt.compare(password, u.passwordHash);
      if (!ok) return res.status(400).json({ error: 'invalid credentials' });
      const token = signToken({ id: u.id });
      return res.json({ token, user: { id: u.id, username: u.username, name: u.name, bio: u.bio } });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'login failed' });
  }
});

// --- Profiles ---
app.get('/api/users/:id', async (req, res) => {
  try {
    const id = req.params.id;
    if (useMongo) {
      const u = await UserModel.findById(id).exec();
      if (!u) return res.status(404).json({ error: 'not found' });
      return res.json({ id: u._id, username: u.username, name: u.name, bio: u.bio });
    } else {
      const u = mem.users.find(x => x.id === id);
      if (!u) return res.status(404).json({ error: 'not found' });
      return res.json({ id: u.id, username: u.username, name: u.name, bio: u.bio });
    }
  } catch (err) {
    res.status(500).json({ error: 'failed' });
  }
});

app.put('/api/users/me', authMiddleware, async (req, res) => {
  try {
    const { name, bio } = req.body;
    if (useMongo) {
      const u = await UserModel.findByIdAndUpdate(req.user.id, { name, bio }, { new: true }).exec();
      return res.json({ id: u._id, username: u.username, name: u.name, bio: u.bio });
    } else {
      const u = mem.users.find(x => x.id === req.user.id);
      if (!u) return res.status(404).json({ error: 'not found' });
      if (typeof name === 'string') u.name = name;
      if (typeof bio === 'string') u.bio = bio;
      return res.json({ id: u.id, username: u.username, name: u.name, bio: u.bio });
    }
  } catch (err) {
    res.status(500).json({ error: 'update failed' });
  }
});

// --- Posts ---
// list posts (paginated optionally)
app.get('/api/posts', async (req, res) => {
  try {
    if (useMongo) {
      const docs = await PostModel.find().sort({ createdAt: -1 }).limit(100).
